#include "IHaxeExternGenerator.h"
#include <Features/IModularFeatures.h>
#include "HaxeGenerator.h"
#include "Misc/Paths.h"
#include "HaxeTypes.h"

DEFINE_LOG_CATEGORY(LogHaxeExtern);

using namespace HaxeGenerator;

static const FString prelude =
  TEXT(" * \n")
  TEXT(" * WARNING! This file was autogenerated by: \n")
  TEXT(" *  _   _ _   _ __   __ \n")
  TEXT(" * | | | | | | |\\ \\ / / \n")
  TEXT(" * | | | | |_| | \\ V /  \n")
  TEXT(" * | | | |  _  | /   \\  \n")
  TEXT(" * | |_| | | | |/ /^\\ \\ \n")
  TEXT(" *  \\___/\\_| |_/\\/   \\/ \n")
  TEXT(" * \n");

static const FString prelude2 =
  TEXT(" * This file was autogenerated by UnrealHxGenerator using UHT definitions.\n")
  TEXT(" * It only includes UPROPERTYs and UFUNCTIONs. Do not modify it!\n")
  TEXT(" * In order to add more definitions, create or edit a type with the same name/package, but with an `_Extra` suffix\n");

static const FString preludeComment = FString(TEXT("/**\n")) + prelude + prelude2 + FString(TEXT("**/\n"));

static TSet<FString> getReadOnlyStructNames() {
  // CppStuctOps doesn't work inside the header parser
  // so we need to manually add non-copy fields here
  TSet<FString> ret;
  ret.Add(TEXT("SkeletalMeshComponentEndPhysicsTickFunction"));
  ret.Add(TEXT("SkeletalMeshComponentClothTickFunction"));
  ret.Add(TEXT("StaticMeshComponentLODInfo"));
  ret.Add(TEXT("KeyHandleMap"));
  ret.Add(TEXT("RichCurveKey"));
  ret.Add(TEXT("PointerToUberGraphFrame"));
  ret.Add(TEXT("TickFunction"));
  ret.Add(TEXT("ActorTickFunction"));
  ret.Add(TEXT("ActorComponentTickFunction"));
  ret.Add(TEXT("PrimitiveComponentPostPhysicsTickFunction"));
  ret.Add(TEXT("StartPhysicsTickFunction"));
  ret.Add(TEXT("EndPhysicsTickFunction"));
  ret.Add(TEXT("StartAsyncSimulationFunction"));
  ret.Add(TEXT("LevelCollection"));
  ret.Add(TEXT("CharacterMovementComponentPostPhysicsTickFunction"));
  ret.Add(TEXT("BodyInstance"));
  ret.Add(TEXT("StartPhysics2DTickFunction"));
  ret.Add(TEXT("EndPhysics2DTickFunction"));
  ret.Add(TEXT("TestTickFunction"));
  ret.Add(TEXT("CachedMovieSceneEvaluationTemplate"));
  ret.Add(TEXT("MovieSceneEvaluationTrack"));
  return ret;
}

static bool structHasCopy(UScriptStruct *inStruct) {
  static TSet<FString> structNames = getReadOnlyStructNames();
  return !structNames.Contains(inStruct->GetName());
}

class FHaxeExternGenerator : public IHaxeExternGenerator {
protected:
  FString m_pluginPath;
  FString m_outPath;
  FHaxeTypes m_types;
  TMap<FString, FString> m_partialFiles;
  static FString currentModule;
public:

  virtual void StartupModule() override {
    IModularFeatures::Get().RegisterModularFeature(TEXT("ScriptGenerator"), this);
  }

  virtual void ShutdownModule() override {
    IModularFeatures::Get().UnregisterModularFeature(TEXT("ScriptGenerator"), this);
  }

  /** Name of module that is going to be compiling generated script glue */
  virtual FString GetGeneratedCodeModuleName() const override {
    return TEXT("Engine");
  }

  /** Returns true if this plugin supports exporting scripts for the specified target. This should handle game as well as editor target names */
  virtual bool SupportsTarget(const FString& TargetName) const override {
    FString env = FPlatformMisc::GetEnvironmentVariable(TEXT("GENERATE_EXTERNS"));
    LOG("Supports target: %d", !env.IsEmpty());
    return !env.IsEmpty();
  }

  /** Returns true if this plugin supports exporting scripts for the specified module */
  virtual bool ShouldExportClassesForModule(const FString& ModuleName, EBuildModuleType::Type ModuleType, const FString& ModuleGeneratedIncludeDirectory) const override {
    currentModule = ModuleName;
    return ModuleName != TEXT("HaxeInit");
  }

  /** Initializes this plugin with build information */
  virtual void Initialize(const FString& RootLocalPath, const FString& RootBuildPath, const FString& OutputDirectory, const FString& IncludeBase) override {
    FString pluginPath = FPlatformMisc::GetEnvironmentVariable(TEXT("EXTERN_OUTPUT_DIR"));
    LOG("Output dir: %s", *pluginPath);
    if (pluginPath.IsEmpty()) {
      UE_LOG(LogHaxeExtern, Fatal, TEXT("No EXTERN_OUTPUT_DIR was set"));
    }
    m_pluginPath = pluginPath;
    if (m_pluginPath.Len() == 0) {
      m_pluginPath = IncludeBase + TEXT("/../../");
    }
    FString externOutPath = FPlatformMisc::GetEnvironmentVariable(TEXT("EXTERN_FULL_OUT_PATH"));
    if (externOutPath.IsEmpty()) {
      m_outPath = m_pluginPath / TEXT("Haxe/Externs");
    } else {
      m_outPath = externOutPath;
    }
    this->m_types = FHaxeTypes(m_outPath);
  }

  /** Exports a single class. May be called multiple times for the same class (as UHT processes the entire hierarchy inside modules. */
  virtual void ExportClass(class UClass* Class, const FString& SourceHeaderFilename, const FString& GeneratedHeaderFilename, bool bHasChanged) override {
    FString comment = Class->GetMetaData(TEXT("ToolTip"));
    m_types.touchClass(Class, SourceHeaderFilename, currentModule);
  }

  void saveFile(const FString& file, FString& contents, bool append) {
    FString lastContents;
    if (append) {
      FString &refContents = m_partialFiles.FindOrAdd(file);
      if (!refContents.IsEmpty()) {
        refContents += TEXT("\n\n");
      }
      refContents += contents;
    } else if (!FFileHelper::LoadFileToString(lastContents, *file, FFileHelper::EHashOptions::None) || lastContents != contents) {
      if (!FFileHelper::SaveStringToFile(contents, *file, FFileHelper::EEncodingOptions::ForceUTF8WithoutBOM)) {
        UE_LOG(LogHaxeExtern, Fatal, TEXT("Cannot write file at path %s"), *file);
      }
    } else {
      LOG("File %s is up-to-date", *file);
    }
  }

  void saveFile(const FHaxeTypeRef& inHaxeType, FString& contents, TSet<FString>& refTouched, TSet<FString>& refAppend) {
    auto& fileMan = IFileManager::Get();
    auto outPath = this->m_outPath / FString::Join(inHaxeType.pack, TEXT("/"));
    if (!fileMan.DirectoryExists(*outPath)) {
      fileMan.MakeDirectory(*outPath, true);
    }

    FString file;
    if (inHaxeType.haxeModule.IsEmpty()) {
      file = outPath / inHaxeType.name + TEXT(".hx");
    } else {
      file = outPath / inHaxeType.haxeModule + TEXT(".hx");
    }
    FPaths::MakeStandardFilename(file);
    if (inHaxeType.pack.Num() > 0) {
      if (!refTouched.Contains(file)) {
        contents = preludeComment + FString(TEXT("package ")) + FString::Join(inHaxeType.pack, TEXT(".")) + TEXT(";\n\n") + contents;
      }
    }

    FString name = FString::Join(inHaxeType.pack, TEXT(".")) + TEXT(".") + inHaxeType.name;

    saveFile(file, contents, refAppend.Contains(name));
    refTouched.Add(file);
  }

  /** Called once all classes have been exported */
  virtual void FinishExport() override {
    for (FRawObjectIterator it(false); it; ++it) {
      UObject* obj = (UObject*) it->Object;
      if (obj->HasAnyFlags(RF_ClassDefaultObject)) {
        continue;
      }
      if (UField* cls = Cast<UField>(obj)) {
        if (UScriptStruct* ustruct = Cast<UScriptStruct>(cls)) {
          m_types.touchStruct(ustruct, nullptr);
        } else if (UEnum* uenum = Cast<UEnum>(cls)) {
          m_types.touchEnum(uenum, nullptr);
        } else if (UFunction* ufunc = Cast<UFunction>(cls)) {
          if ((ufunc->FunctionFlags & FUNC_Delegate) != 0) {
            m_types.touchDelegate(ufunc, nullptr);
          }
        }
      }
    }

    TSet<FString> appendModules;
    for (auto& udelegate : m_types.getAllDelegates()) {
      if (!udelegate->haxeType.haxeModule.IsEmpty()) {
        FString name = FString::Join(udelegate->haxeType.pack, TEXT(".")) + TEXT(".") + udelegate->haxeType.name;
        appendModules.Add(name);
      }
    }

    for (auto& cls : m_types.getAllClasses()) {
      if (!cls->haxeType.haxeModule.IsEmpty()) {
        FString name = FString::Join(cls->haxeType.pack, TEXT(".")) + TEXT(".") + cls->haxeType.name;
        appendModules.Add(name);
      }
    }

    for (auto& s : m_types.getAllStructs()) {
      if (!s->haxeType.haxeModule.IsEmpty()) {
        FString name = FString::Join(s->haxeType.pack, TEXT(".")) + TEXT(".") + s->haxeType.name;
        appendModules.Add(name);
      }
    }

    for (auto& uenum : m_types.getAllEnums()) {
      if (!uenum->haxeType.haxeModule.IsEmpty()) {
        FString name = FString::Join(uenum->haxeType.pack, TEXT(".")) + TEXT(".") + uenum->haxeType.name;
        appendModules.Add(name);
      }
    }


    TSet<FString> touchedFiles;
    // now start generating
    for (auto& udelegate : m_types.getAllDelegates()) {
      if (!HaxeTypeHelpers::shouldGenerateModule(udelegate->haxeType.module, true)) {
        continue;
      }
      auto gen = FHaxeGenerator(this->m_types);
      if (gen.generateDelegate(udelegate)) {
        FString genString = gen.toString();
        saveFile(udelegate->haxeType, genString, touchedFiles, appendModules);
      } else {
        m_types.doNotExportDelegate(udelegate);
      }
    }

    for (auto& cls : m_types.getAllClasses()) {
      if (!HaxeTypeHelpers::shouldGenerateModule(cls->haxeType.module, true)) {
        continue;
      }
      auto gen = FHaxeGenerator(this->m_types);
      gen.generateClass(cls);
      FString genString = gen.toString();
      saveFile(cls->haxeType, genString, touchedFiles, appendModules);
    }

    for (auto& s : m_types.getAllStructs()) {
      if (!HaxeTypeHelpers::shouldGenerateModule(s->haxeType.module, true)) {
        continue;
      }
      auto gen = FHaxeGenerator(this->m_types);
      gen.generateStruct(s);
      FString genString = gen.toString();
      saveFile(s->haxeType, genString, touchedFiles, appendModules);
    }

    for (auto& uenum : m_types.getAllEnums()) {
      if (!HaxeTypeHelpers::shouldGenerateModule(uenum->haxeType.module, true)) {
        continue;
      }
      auto gen = FHaxeGenerator(this->m_types);
      gen.generateEnum(uenum);
      FString genString = gen.toString();
      saveFile(uenum->haxeType, genString, touchedFiles, appendModules);
    }

    for (auto partialsIt = m_partialFiles.CreateIterator() ; partialsIt; ++partialsIt) {
      saveFile(partialsIt.Key(), partialsIt.Value(), false);
    }

    if (HaxeTypeHelpers::compilingGameCode()) {
      class FDeleteVisitor : public IPlatformFile::FDirectoryVisitor {
      public:
        TSet<FString> m_touchedFiles;
        FDeleteVisitor(TSet<FString> touchedFiles) : m_touchedFiles(touchedFiles) {
        }

        virtual bool Visit(const TCHAR* filename, bool isDir) override {
          if (isDir) {
            return true;
          }
          FString file = FString(filename);
          FPaths::MakeStandardFilename(file);
          if (!m_touchedFiles.Contains(file)) {
            auto& fileMan = IFileManager::Get();
            LOG("Deleting uneeded file %s", *filename);
            if (!fileMan.Delete(filename, true, true, true)) {
              UE_LOG(LogHaxeExtern, Warning, TEXT("Error while deleting file %s"), filename);
            }
          }
          return true;
        }
      };
      FDeleteVisitor visitor(touchedFiles);
      auto& fileMan = IFileManager::Get();
      fileMan.IterateDirectoryRecursively(*this->m_outPath, visitor);
    }
    // auto outPath = this->m_outPath / FString::Join(inHaxeType.pack, TEXT("/"));
    // if (!fileMan.DirectoryExists(*outPath)) {
    //   fileMan.MakeDirectory(*outPath, true);
    // }

    // FString file;
    // if (inHaxeType.haxeModule.IsEmpty()) {
    //   file = outPath / inHaxeType.name + TEXT(".hx");
    // } else {
    //   file = outPath / inHaxeType.haxeModule + TEXT(".hx");
    // }
  }

  /** Name of the generator plugin, mostly for debuggind purposes */
  virtual FString GetGeneratorName() const override {
    return TEXT("Haxe Extern Generator Plugin");
  }

};

IMPLEMENT_MODULE(FHaxeExternGenerator, UnrealHxGenerator)

static TArray<FString> getUFunctionFlags(UFunction *func) {
  TArray<FString> ret;
  if (func->HasAllFunctionFlags(FUNC_Event | FUNC_BlueprintEvent)) {
    if (func->HasAnyFunctionFlags(FUNC_Native)) {
      ret.Push(TEXT("BlueprintNativeEvent"));
    } else {
      ret.Push(TEXT("BlueprintImplementableEvent"));
    }
  }
  if (func->HasAnyFunctionFlags(FUNC_Net)) {
    if (func->HasAnyFunctionFlags(FUNC_NetServer)) {
      ret.Push(TEXT("Server"));
    } else if (func->HasAnyFunctionFlags(FUNC_NetClient)) {
      ret.Push(TEXT("Client"));
    } else {
      ret.Push(TEXT("NetMulticast"));
    }
  }
  if (func->HasAnyFunctionFlags(FUNC_BlueprintCallable)) {
    ret.Push(TEXT("BlueprintCallable"));
  }

  return ret;
}

static TArray<FString> getUPropertyFlags(UProperty *prop) {
  TArray<FString> ret;
  auto& getter = prop->GetMetaData(TEXT("BlueprintGetter"));
  if (!getter.IsEmpty()) {
    ret.Push(FString(TEXT("BlueprintGetter=")) + getter);
  }
  auto& setter = prop->GetMetaData(TEXT("BlueprintSetter"));
  if (!setter.IsEmpty()) {
    ret.Push(FString(TEXT("BlueprintSetter=")) + setter);
  }
  return ret;
}

FString FHaxeExternGenerator::currentModule = FString();

FString FHaxeGenerator::getHeaderPath(UPackage *inPack, const FString& inPath) {
  if (inPath.IsEmpty()) {
    // this is a particularity of UHT - it sometimes adds no header path to some of the core UObjects
    return FString("CoreUObject.h");
  }
  if (FPaths::IsRelative(inPath)) {
    return inPath.Replace(TEXT("\\"),TEXT("/"));
  }
  auto lastSlash = inPath.Find(TEXT("/"), ESearchCase::CaseSensitive, ESearchDir::FromEnd, inPath.Len());
  auto lastBackslash = inPath.Find(TEXT("\\"), ESearchCase::CaseSensitive, ESearchDir::FromEnd, inPath.Len());
  int startPos = (lastSlash > lastBackslash) ? lastSlash : lastBackslash;
  if (startPos < 0) {
    return inPath;
  }

  int32 index = inPath.Find(TEXT("Public"), ESearchCase::IgnoreCase, ESearchDir::FromEnd, startPos);
  if (index < 0) {
    index = inPath.Find(TEXT("Classes"), ESearchCase::IgnoreCase, ESearchDir::FromEnd, startPos);
    if (index >= 0)
      index += sizeof("Classes");
  } else {
    index += sizeof("Public");
  }
  if (index < 0) {
    auto pack = inPack->GetName().RightChop( sizeof("/Script") );
    index = inPath.Find(pack, ESearchCase::IgnoreCase, ESearchDir::FromEnd, startPos);
    if (index >= 0)
      index += pack.Len() + 1;
  }
  if (index < 0) {
    index = inPath.Find(TEXT("Private"), ESearchCase::IgnoreCase, ESearchDir::FromEnd, startPos);
  }
  if (index < 0) {
    index = startPos;
  }
  if (index >= 0) {
    int len = inPath.Len();
    while (len > index && (inPath[index - 1] == TCHAR('/') || inPath[index - 1] == TCHAR('\\'))) {
      index++;
      //advance index
    }
    return inPath.RightChop(index - 1).Replace(TEXT("\\"), TEXT("/"));
  }

  UE_LOG(LogHaxeExtern, Fatal, TEXT("Cannot determine header path of %s on package %s"), *inPath, *inPack->GetName());
  return FString();
}

void FHaxeGenerator::generateFields(UStruct *inStruct, bool onlyProps = false) {
  UClass *uclass = nullptr;
  if (inStruct->IsA<UClass>()) {
    uclass = Cast<UClass>(inStruct);
  }
  auto wasEditorOnlyData = false;
  auto wasEditorOnly = false;
  TArray<UField *> fields;
  for (TFieldIterator<UField> invFields(inStruct, EFieldIteratorFlags::ExcludeSuper); invFields; ++invFields) {
    fields.Push(*invFields);
  }
  while (fields.Num() > 0) {
    // reverse field iterator so fields are declared in the same order as C++ code
    auto field = fields.Pop(false);
    if (field->IsA<UProperty>()) {
      auto prop = Cast<UProperty>(field);
      if (prop->HasAnyPropertyFlags(CPF_Protected) && prop->IsA<UBoolProperty>()) {
        continue; // we cannot generate code for protected bit-fields
      }
      FString type;
      if (wasEditorOnly) {
        m_buf << TEXT("#end // WITH_EDITOR") << Newline();
        wasEditorOnly = false;
      }

      if ((prop->HasAnyFlags(RF_Public) || prop->HasAnyPropertyFlags(CPF_Protected)) && upropType(prop, type)) {
        auto isEditorOnlyData = prop->HasAnyPropertyFlags(CPF_EditorOnly);
        if (isEditorOnlyData != wasEditorOnlyData) {
          if (isEditorOnlyData) {
            m_buf << TEXT("#if WITH_EDITORONLY_DATA") << Newline();
          } else {
            m_buf << TEXT("#end // WITH_EDITORONLY_DATA") << Newline();
          }
          wasEditorOnlyData = isEditorOnlyData;
        }
        auto& propComment = prop->GetMetaData(TEXT("ToolTip"));
        if (!propComment.IsEmpty()) {
          m_buf << Comment(propComment);
        }

        if (prop->HasAnyPropertyFlags( CPF_Deprecated )) {
          // properties can still be accessed without annoying warnings. So let's generate them and add @:deprecated on the Haxe side
          m_buf << TEXT("@:deprecated ");
        }
        m_buf << TEXT("@:uproperty");
        auto flags = getUPropertyFlags(prop);
        if (flags.Num() != 0) {
          m_buf << TEXT("(") << FString::Join(flags, TEXT(", ")) << TEXT(") ");
        } else {
          m_buf << TEXT(" ");
        }
        auto readOnly = isReadOnly(prop);
        m_buf
          << (prop->HasAnyPropertyFlags(CPF_Protected) ? TEXT("private var ") : TEXT("public var "))
          << prop->GetNameCPP()
          << (readOnly ? TEXT("(default,never)") : TEXT(""));
        // TODO see if the property is read-only; this might not be supported by UHT atm?
        m_buf << TEXT(" : ") << type << TEXT(";") << Newline();
      }
    } else if (field->IsA<UFunction>()) {
      auto func = Cast<UFunction>(field);
      if (onlyProps && (func->FunctionFlags & FUNC_RequiredAPI) == 0) {
        continue;
      }
      LOG("Starting to generate %s (flags %x)", *func->GetName(), (int) func->FunctionFlags);
      if (this->m_generatedFields.Contains(func->GetName())) {
        LOG("continuing %s %s", *uclass->GetName(), *func->GetOwnerClass()->GetName());
        // we don't need to generate overridden functions' glue code
        continue;
      } else if (func->HasAnyFunctionFlags(FUNC_Private | FUNC_Delegate)) {
        // we can't access private functions
        // Delegate signatures are a weird piece of code that don't seem to be exported
        continue;
      }
      auto isEditorOnly = func->HasAnyFunctionFlags(FUNC_EditorOnly);
      if (wasEditorOnlyData) {
        m_buf << TEXT("#end // WITH_EDITORONLY_DATA") << Newline();
        wasEditorOnlyData = false;
      }
      if (isEditorOnly != wasEditorOnly) {
        if (isEditorOnly) {
          m_buf << TEXT("#if WITH_EDITOR") << Newline();
        } else {
          m_buf << TEXT("#end // WITH_EDITOR") << Newline();
        }
        wasEditorOnly = isEditorOnly;
      }

      this->m_generatedFields.Add(func->GetName());
      // we need to create a local buffer because we will only know if we should
      // generate this function in the end of its processing
      FHelperBuf curBuf;

      curBuf << TEXT("@:ufunction");
      auto flags = getUFunctionFlags(func);
      if (flags.Num() != 0) {
        curBuf << TEXT("(") << FString::Join(flags, TEXT(", ")) << TEXT(") ");
      } else {
        curBuf << TEXT(" ");
      }
      if (func->HasAnyFunctionFlags(FUNC_Const)) {
        curBuf << TEXT("@:thisConst ");
      }

      LOG("Generating %s (flags %x)", *func->GetName(), (int) func->FunctionFlags);
      if (func->HasAnyFunctionFlags(FUNC_Static)) {
        curBuf << TEXT("static ");
      } else if (func->HasAnyFunctionFlags(FUNC_Final)) {
        curBuf << TEXT("@:final ");
      }
      curBuf << (func->HasAnyFunctionFlags(FUNC_Public) ? TEXT("public function ") : TEXT("private function ")) << func->GetName() << TEXT("(");
      auto first = true;
      auto shouldExport = true;
      bool hasReturnValue = false;
      for (TFieldIterator<UProperty> params(func); params; ++params) {
        check(!hasReturnValue);
        auto param = *params;
        FString type;
        if (upropType(param, type)) {
          if (param->HasAnyPropertyFlags(CPF_ReturnParm)) {
            hasReturnValue = true;
            curBuf << TEXT(") : ") << type;
          } else {
            if (first) first = false; else curBuf << TEXT(", ");
            bool escapeDefault = false;
            auto defaultValue = func->GetMetaData(*(FString(TEXT("CPP_Default_")) + param->GetName()));
            if (!defaultValue.IsEmpty()) {
              if (param->IsA<UNumericProperty>()
                  || param->IsA<UBoolProperty>()
                 )
              {
                // do nothing - defaultValue will be consumed later
              } else if (defaultValue == FString(TEXT("nullptr")) || defaultValue == FString(TEXT("NULL")) || defaultValue == FString(TEXT("null"))) {
                defaultValue = FString("null");
              } else {
                curBuf << TEXT("@:opt(\"") << Escaped(defaultValue) << TEXT("\") ");
                defaultValue = FString();
              }
            } else if ( !( (defaultValue = func->GetMetaData(*param->GetName())).IsEmpty() ) ) {
              curBuf << TEXT("@:bpopt(\"") << Escaped(defaultValue) << TEXT("\") ");
              defaultValue = FString();
            }
            curBuf << param->GetNameCPP() << TEXT(" : ") << type;
            if (!defaultValue.IsEmpty()) {
              curBuf << TEXT(" = ");
              if (escapeDefault) {
                curBuf << TEXT("\"") << Escaped(defaultValue) << TEXT("\"");
              } else {
                curBuf << defaultValue;
              }
            }
          }
        } else {
          shouldExport = false;
          break;
        }
      }
      if (!hasReturnValue) {
        curBuf << TEXT(") : Void;");
      } else {
        curBuf << TEXT(";");
      }
      if (shouldExport) {
        // seems like UHT doesn't support editor-only ufunctions
        if (wasEditorOnlyData) {
          wasEditorOnlyData = false;
          m_buf << TEXT("#end // WITH_EDITORONLY_DATA") << Newline();
        }
        auto& fnComment = func->GetMetaData(TEXT("ToolTip"));
        if (!fnComment.IsEmpty()) {
          m_buf << Comment(fnComment);
        }
        m_buf << curBuf.toString() << Newline();
      }
    } else {
      UE_LOG(LogHaxeExtern, Warning, TEXT("Field %s is not a UFUNCTION or UPROERTY"), *field->GetName());
    }
  }
  if (wasEditorOnlyData) {
    wasEditorOnlyData = false;
    m_buf << TEXT("#end // WITH_EDITORONLY_DATA") << Newline();
  }
  if (wasEditorOnly) {
    wasEditorOnly = false;
    m_buf << TEXT("#end // WITH_EDITOR") << Newline();
  }
}

void FHaxeGenerator::collectSuperFields(UStruct *inSuper) {
  for (TFieldIterator<UField> fields(inSuper, EFieldIteratorFlags::IncludeSuper); fields; ++fields) {
    auto field = *fields;
    this->m_generatedFields.Add(field->GetName());
  }
}

bool FHaxeGenerator::generateClass(const ClassDescriptor *inClass) {
  auto hxType = inClass->haxeType;

  auto isInterface = hxType.kind == ETypeKind::KUInterface;
  auto uclass = inClass->uclass;
  bool isNoExport = (uclass->ClassFlags & CLASS_NoExport) != 0;
  bool isMinimalAPI = (uclass->ClassFlags & CLASS_MinimalAPI) != 0;
  auto shouldNotExport = isMinimalAPI || (!uclass->HasAnyClassFlags( CLASS_RequiredAPI | CLASS_MinimalAPI ) && !inClass->header.IsEmpty() && uclass->GetName() != TEXT("Object"));
  // comment
  auto comment = uclass->GetMetaData(TEXT("ToolTip"));
  if (isNoExport) {
    comment = TEXT("WARNING: This type is defined as NoExport by UHT. It will be empty because of it\n\n") + comment;
  }
  if (isMinimalAPI) {
    comment = TEXT("WARNING: This type was defined as MinimalAPI on its declaration. Because of that, its properties/methods are inaccessible\n\n") + comment;
  } else if (shouldNotExport) {
    comment = TEXT("WARNING: This type was not defined as DLL export on its declaration. Because of that, some of its methods are inaccessible\n\n") + comment;
  }

  if (!comment.IsEmpty()) {
    m_buf << Comment(comment);
  }
  // @:umodule
  if (!hxType.module.IsEmpty()) {
    m_buf << TEXT("@:umodule(\"") << Escaped(hxType.module) << TEXT("\")") << Newline();
  }
  if (!hxType.uname.IsEmpty() && hxType.uname != hxType.name) {
    m_buf << TEXT("@:uname(\"") << Escaped(hxType.uname) << TEXT("\")") << Newline();
  }
  if (hxType.haxeGenerated) {
    m_buf << TEXT("@:haxeGenerated") << Newline();
  }
  // @:glueCppIncludes
  m_buf << TEXT("@:glueCppIncludes(\"") << Escaped(getHeaderPath(inClass->uclass->GetOuterUPackage(), inClass->header)) << TEXT("\")") << Newline();
  if (shouldNotExport && !isMinimalAPI) {
    m_buf << TEXT("@:noClass ");
  }

  m_buf << TEXT("@:uextern @:uclass extern ") << (isInterface ? TEXT("interface ") : TEXT("class ")) << hxType.name;
  if (!isInterface) {
    auto superUClass = uclass->GetSuperClass();
    const ClassDescriptor *super = nullptr;
    if (nullptr != superUClass) {
      super = m_haxeTypes.getDescriptor(superUClass);
      while (super == nullptr) {
        // if superclass was not exported, try supers' super
        superUClass = superUClass ->GetSuperClass();
        if (superUClass != nullptr) {
          super = m_haxeTypes.getDescriptor(superUClass);
        } else {
          break;
        }
      }

      if (super != nullptr) {
        this->collectSuperFields(superUClass);
        m_buf << " extends " << super->haxeType.toString();
      }
    }
  }

  const auto implements = isInterface ? TEXT(" extends ") : TEXT(" implements ");
  // for now it doesn't seem that Unreal supports interfaces that extend other interfaces, but let's make ourselves ready for it
  for (auto& impl : uclass->Interfaces) {
    auto ifaceType = m_haxeTypes.getDescriptor(impl.Class);
    if (ifaceType != nullptr) {
      if (ifaceType->haxeType.kind != ETypeKind::KNone) {
        m_buf << implements << ifaceType->haxeType.toString();
      }
    }
  }
  m_buf << Begin(TEXT(" {"));
  {
    if (!isNoExport) {
      this->generateFields(uclass, shouldNotExport);
    }
    for (auto& impl : uclass->Interfaces) {
      m_buf << TEXT("// ") << impl.Class->GetName() << TEXT(" interface implementation") << Newline();
      this->generateFields(impl.Class);
    }
  }
  m_buf << End();
  return true;
}

void FHaxeGenerator::generateIncludeMetas(const NonClassDescriptor *inDesc) {
  m_buf << TEXT("@:glueCppIncludes(");
  auto first = true;
  for (auto& header : inDesc->getHeaders()) {
    if (first) first = false; else m_buf << TEXT(", ");
    m_buf << TEXT("\"") << Escaped(getHeaderPath(inDesc->module->getPackage(), header)) << TEXT("\"");
  }
  m_buf << TEXT(")") << Newline();
}

bool FHaxeGenerator::generateDelegate(const DelegateDescriptor *inDelegate) {
  auto hxType = inDelegate->haxeType;
  auto udelegate = inDelegate->delegateSignature;
  FHelperBuf commentBuf;
  commentBuf << udelegate->GetMetaData(TEXT("ToolTip"));
  commentBuf.newLineIfNeeded();
  FHelperBuf paramNames;
  FHelperBuf curBuf;
  // @:umodule
  if (!hxType.module.IsEmpty()) {
    curBuf << TEXT("@:umodule(\"") << Escaped(hxType.module) << TEXT("\")") << Newline();
  }

  auto uname = hxType.uname;
  auto outer = udelegate->GetOuter();
  if (!outer->IsA<UPackage>() && outer->IsA<UStruct>()) {
    auto ustructOuter = Cast<UStruct>(outer);
    uname = ustructOuter->GetPrefixCPP() + ustructOuter->GetName() + TEXT(".") + uname;
  }
  if (!uname.IsEmpty() && uname != hxType.name) {
    curBuf << TEXT("@:uname(\"") << Escaped(uname) << TEXT("\")") << Newline();
  }
  if (hxType.haxeGenerated) {
    curBuf << TEXT("@:haxeGenerated") << Newline();
  }

  curBuf << TEXT("typedef ") << hxType.name << TEXT(" = ");
  if ((udelegate->FunctionFlags & FUNC_MulticastDelegate) == 0) {
    curBuf << TEXT("unreal.DynamicDelegate<");
  } else {
    curBuf << TEXT("unreal.DynamicMulticastDelegate<");
  }
  curBuf << hxType.name << TEXT(", ");

  auto first = true;
  auto shouldExport = true;
  bool hasReturnValue = false;
  for (TFieldIterator<UProperty> params(udelegate); params; ++params) {
    check(!hasReturnValue);
    auto param = *params;
    commentBuf << TEXT("@param ") << param->GetName() << Newline();
    paramNames << TEXT("@:uParamName(\"") << Escaped(param->GetName()) << TEXT("\")") << Newline();

    FString type;
    if (upropType(param, type)) {
      if (param->HasAnyPropertyFlags(CPF_ReturnParm)) {
        if (first) {
          curBuf << TEXT("Void->");
        }
        hasReturnValue = true;
        curBuf << type;
      } else {
        curBuf << type << TEXT("->");
      }
    } else {
      shouldExport = false;
      break;
    }
    first = false;
  }
  if (!shouldExport) {
    LOG("Could not generate delegate %s", *hxType.name);
    return false;
  } else {
    if (!hasReturnValue) {
      if (first) {
        curBuf << TEXT("Void->");
      }
      curBuf << TEXT("Void");
    }
    curBuf << TEXT(">;");
    // @:glueCppIncludes
    auto comment = commentBuf.toString();
    if (!comment.IsEmpty()) {
      m_buf << Comment(comment);
    }
    generateIncludeMetas(inDelegate);
    m_buf << paramNames.toString();
    m_buf << curBuf;
    return true;
  }
}

bool FHaxeGenerator::generateStruct(const StructDescriptor *inStruct) {
  auto hxType = inStruct->haxeType;

  auto ustruct = inStruct->ustruct;
  // comment
  bool isNoExport = (ustruct->StructFlags & STRUCT_NoExport) != 0;
  auto isNotRequired = (ustruct->StructFlags & STRUCT_RequiredAPI) == 0;
  auto comment = ustruct->GetMetaData(TEXT("ToolTip"));
  if (isNoExport) {
    comment = TEXT("WARNING: This type is defined as NoExport by UHT. It will be empty because of it\n\n") + comment;
  }

  if (!comment.IsEmpty()) {
    m_buf << Comment(comment);
  }
  // @:umodule
  if (!hxType.module.IsEmpty()) {
    m_buf << TEXT("@:umodule(\"") << Escaped(hxType.module) << TEXT("\")") << Newline();
  }
  if (!hxType.uname.IsEmpty() && hxType.uname != hxType.name) {
    m_buf << TEXT("@:uname(\"") << Escaped(hxType.uname) << TEXT("\")") << Newline();
  }
  if (hxType.haxeGenerated) {
    m_buf << TEXT("@:haxeGenerated") << Newline();
  }
  // @:glueCppIncludes
  generateIncludeMetas(inStruct);
  auto ops = inStruct->ustruct->GetCppStructOps();
  bool isAbstract = ops != nullptr ? ops->IsAbstract() : false;
  if (isAbstract || isNotRequired ||!structHasCopy(inStruct->ustruct)) {
    // we don't know if == or the copy constructors are inline or not
    m_buf << TEXT("@:noCopy ");
  }
  if (isAbstract || isNotRequired || (ops != nullptr && !ops->HasIdentical())) {
    m_buf << TEXT("@:noEquals ");
  }
  m_buf << TEXT("@:uextern @:ustruct extern ") << TEXT("class ") << hxType.name;

  auto superStruct = ustruct->GetSuperStruct();
  const StructDescriptor *super = nullptr;
  if (nullptr != superStruct) {
    super = m_haxeTypes.getDescriptor((UScriptStruct *) superStruct);
    while (nullptr == super) {
      superStruct = superStruct->GetSuperStruct();
      if (superStruct != nullptr) {
        super = m_haxeTypes.getDescriptor( (UScriptStruct *) superStruct );
      } else {
        break;
      }
    }
    if (nullptr != super) {
      m_buf << " extends " << super->haxeType.toString();
    }
  }
  m_buf << Begin(TEXT(" {"));
  {
    if (!isNoExport) {
      this->generateFields(ustruct, isNotRequired);
    }
  }
  m_buf << End();
  return true;
}

bool FHaxeGenerator::generateEnum(const EnumDescriptor *inEnum) {
  auto uenum = inEnum->uenum;
  auto hxType = inEnum->haxeType;

  // comment
  auto comment = uenum->GetMetaData(TEXT("ToolTip"));
  if (!comment.IsEmpty()) {
    m_buf << Comment(comment);
  }
  // @:umodule
  if (!hxType.module.IsEmpty()) {
    m_buf << TEXT("@:umodule(\"") << Escaped(hxType.module) << TEXT("\")") << Newline();
  }
  if (hxType.haxeGenerated) {
    m_buf << TEXT("@:haxeGenerated") << Newline();
  }
  // @:glueCppIncludes
  generateIncludeMetas(inEnum);

  m_buf << TEXT("@:uname(\"") << Escaped(uenum->CppType.Replace(TEXT("::"), TEXT("."))) << TEXT("\")") << Newline();
  if (uenum->GetCppForm() == UEnum::ECppForm::EnumClass) {
    m_buf << TEXT("@:class ");
  }

  m_buf << TEXT("@:uextern @:uenum extern ") << TEXT("enum ") << hxType.name;

  m_buf << Begin(TEXT(" {"));
  for (int i = 0; i < uenum->NumEnums(); i++) {
    auto name = uenum->GetNameStringByIndex(i);
    auto ecomment = uenum->GetMetaData(*(name + TEXT(".") + TEXT("ToolTip")));
    auto displayName = uenum->GetMetaData(*(name + TEXT(".") + TEXT("DisplayName")));
    if (!displayName.IsEmpty()) {
      if (ecomment.IsEmpty()) {
        ecomment = displayName;
      } else {
        ecomment += TEXT("\n@DisplayName ") + displayName;
      }
    }
    if (!ecomment.IsEmpty()) {
      m_buf << Comment(ecomment);
    }

    if (!displayName.IsEmpty()) {
      m_buf << TEXT("@DisplayName(\"") << Escaped(displayName) << "\")" << Newline();
    }
    m_buf << name << TEXT(";") << Newline();
  }

  m_buf << End();

  return true;
}

static void addRef(UProperty *inProp, FString &outString) {
  if (inProp->IsA<UNumericProperty>() || inProp->IsA<UEnumProperty>() || inProp->IsA<UObjectProperty>() || inProp->IsA<UBoolProperty>()) {
    outString += TEXT("unreal.Ref");
  } else {
    outString += TEXT("unreal.PRef");
  }
}

bool FHaxeGenerator::writeWithModifiers(const FString &inName, UProperty *inProp, FString &outType) {
  if (inProp->ArrayDim > 1) {
    // TODO: support array dimensions (e.g. SomeType SomeProp[8])
    return false;
  }
  auto end = FString();
  // check all the flags that interest us
  // UStruct pointers aren't supported; so we're left either with PRef, PStruct and Const to check
  if (inProp->HasAnyPropertyFlags(CPF_ReturnParm)) {
    if (inProp->HasAnyPropertyFlags(CPF_ConstParm)) {
      outType += TEXT("unreal.Const<");
      end += TEXT(">");
    }
    if (inProp->HasAnyPropertyFlags(CPF_ReferenceParm)) {
      addRef(inProp, outType);
      outType += TEXT("<");
      end += TEXT(">");
    }
  } else {
    if (
      inProp->HasAnyPropertyFlags(CPF_ConstParm) ||
      (inProp->HasAnyPropertyFlags(CPF_ReferenceParm) && !inProp->HasAnyPropertyFlags(CPF_OutParm))
    ) {
      outType += TEXT("unreal.Const<");
      end += TEXT(">");
    }
    if (inProp->HasAnyPropertyFlags(CPF_ReferenceParm | CPF_OutParm)) {
      if (inProp->IsA<UObjectProperty>()) {
        // we don't support UObject*& for now
        return false;
      }
      addRef(inProp, outType);
      outType += TEXT("<");
      end += TEXT(">");
    }
  }

  LOG("PROPERTY %s: %s %llx", *inName, *outType, (long long int) inProp->PropertyFlags);

  outType += inName + end;
  return true;
}

bool FHaxeGenerator::writeBasicWithModifiers(const FString &inName, UProperty *inProp, FString &outType) {
  // TODO support basic types' modifiers
  outType += inName;
  return true;
}

static bool canBuildTArrayProp(FString inInner, UProperty *inProp) {
  // HACK: we need this since some types struggle with some operators (e.g. set operator)
  //       we'll need to find a better way to deal with this, but for now we'll just not include that into the built
  if (inInner.Contains(TEXT("FStaticMeshComponentLODInfo"), ESearchCase::CaseSensitive, ESearchDir::FromStart)) {
    return false;
  } else if (inProp->IsA<UNumericProperty>() && Cast<UNumericProperty>(inProp)->GetIntPropertyEnum() != nullptr) {
    // TArray<Enum> is not supported because UHT doesn't let us know if the C++ was declared as either TArray<Enum> or TArray<TEnumAsByte<Enum>>
    return false;
  }
  return true;
}

bool FHaxeGenerator::isReadOnly(UProperty* inProp) {
  if (inProp->HasAnyPropertyFlags(CPF_ConstParm)) {
    return true;
  }
  if (inProp->IsA<UStructProperty>()) {
    auto prop = Cast<UStructProperty>(inProp);
    // auto ops = prop->Struct->GetCppStructOps();
    // if (ops == nullptr) {
    //   UE_LOG(LogHaxeExtern, Warning, TEXT("(struct) TYPE HAS NOT OPS : %s"), *prop->Struct->GetName());
    //   return false;
    // }
    // return !ops->HasCopy();
    //
    return !structHasCopy(prop->Struct);
  }
  return false;
}

bool FHaxeGenerator::upropType(UProperty* inProp, FString &outType) {
  if (inProp->ArrayDim > 1) {
    return false;
  }
  // from the most common to the least
  if (inProp->IsA<UStructProperty>()) {
    auto prop = Cast<UStructProperty>(inProp);
    auto descr = m_haxeTypes.getDescriptor( prop->Struct );
    if (descr == nullptr) {
      UE_LOG(LogHaxeExtern, Warning, TEXT("(struct) TYPE NOT SUPPORTED: %s"), *prop->Struct->GetName());
      // may happen if we never used this in a way the struct is known
      return false;
    }
    return writeWithModifiers(descr->haxeType.toString(), inProp, outType);
  } else if (inProp->IsA<UObjectProperty>()) {
    if (inProp->IsA<UClassProperty>()) {
      auto prop = Cast<UClassProperty>(inProp);
      if (prop->HasAnyPropertyFlags(CPF_UObjectWrapper)) {
        auto descr = m_haxeTypes.getDescriptor(prop->MetaClass);
        if (descr == nullptr) {
          UE_LOG(LogHaxeExtern, Warning, TEXT("(tsubclassof) TYPE NOT SUPPORTED: %s"), *prop->PropertyClass->GetName());
          return false;
        }
        return writeWithModifiers(TEXT("unreal.TSubclassOf<") + descr->haxeType.toString() + TEXT(">"), inProp, outType);
      }
    }
    auto prop = Cast<UObjectProperty>(inProp);
    auto descr = m_haxeTypes.getDescriptor(prop->PropertyClass);
    if (descr == nullptr) {
      UE_LOG(LogHaxeExtern, Warning, TEXT("(uclass) TYPE NOT SUPPORTED: %s"), *prop->PropertyClass->GetName());
      return false;
    }
    return writeWithModifiers(descr->haxeType.toString(), inProp, outType);
  } else if (inProp->IsA<UWeakObjectProperty>()) {
    auto prop = Cast<UWeakObjectProperty>(inProp);
    auto descr = m_haxeTypes.getDescriptor(prop->PropertyClass);
    if (descr == nullptr) {
      UE_LOG(LogHaxeExtern, Warning, TEXT("(uclass) TYPE NOT SUPPORTED: %s"), *prop->PropertyClass->GetName());
      return false;
    }
    return writeWithModifiers(TEXT("unreal.TWeakObjectPtr<") + descr->haxeType.toString() + TEXT(">"), inProp, outType);
  } else if (inProp->IsA<UNumericProperty>()) {
    auto numeric = Cast<UNumericProperty>(inProp);
    UEnum *uenum = numeric->GetIntPropertyEnum();
    if (uenum != nullptr) {
      auto descr = m_haxeTypes.getDescriptor(uenum);
      if (descr == nullptr) {
        return false;
      }
      return writeWithModifiers(descr->haxeType.toString(), inProp, outType);
    }
    if (inProp->IsA<UByteProperty>()) {
      return writeBasicWithModifiers(TEXT("unreal.UInt8"), inProp, outType);
    } else if (inProp->IsA<UInt8Property>()) {
      return writeBasicWithModifiers(TEXT("unreal.Int8"), inProp, outType);
    } else if (inProp->IsA<UInt16Property>()) {
      return writeBasicWithModifiers(TEXT("unreal.Int16"), inProp, outType);
    } else if (inProp->IsA<UIntProperty>()) {
      return writeBasicWithModifiers(TEXT("unreal.Int32"), inProp, outType);
    } else if (inProp->IsA<UInt64Property>()) {
      return writeBasicWithModifiers(TEXT("unreal.Int64"), inProp, outType);
    } else if (inProp->IsA<UUInt16Property>()) {
      return writeBasicWithModifiers(TEXT("unreal.UInt16"), inProp, outType);
    } else if (inProp->IsA<UUInt32Property>()) {
      return writeBasicWithModifiers(TEXT("unreal.FakeUInt32"), inProp, outType);
    } else if (inProp->IsA<UUInt64Property>()) {
      return writeBasicWithModifiers(TEXT("unreal.FakeUInt64"), inProp, outType);
    } else if (inProp->IsA<UFloatProperty>()) {
      return writeBasicWithModifiers(TEXT("unreal.Float32"), inProp, outType);
    } else if (inProp->IsA<UDoubleProperty>()) {
      return writeBasicWithModifiers(TEXT("unreal.Float64"), inProp, outType);
    } else {
      UE_LOG(LogHaxeExtern, Warning, TEXT("NUMERIC TYPE NOT SUPPORTED: %s"), *inProp->GetClass()->GetName());
      return false;
    }
    return true;
  } else if (inProp->IsA<UEnumProperty>()) {
    auto enumProp = Cast<UEnumProperty>(inProp);
    UEnum *uenum = enumProp->GetEnum();
    auto descr = m_haxeTypes.getDescriptor(uenum);
    if (descr == nullptr) {
      return false;
    }
    return writeWithModifiers(descr->haxeType.toString(), inProp, outType);
  } else if (inProp->IsA<UBoolProperty>()) {
    return writeBasicWithModifiers(TEXT("Bool"), inProp, outType);
    return true;
  } else if (inProp->IsA<UNameProperty>()) {
    return writeWithModifiers(TEXT("unreal.FName"), inProp, outType);
  } else if (inProp->IsA<UStrProperty>()) {
    return writeWithModifiers(TEXT("unreal.FString"), inProp, outType);
  } else if (inProp->IsA<UTextProperty>()) {
    return writeWithModifiers(TEXT("unreal.FText"), inProp, outType);
  } else if (inProp->IsA<UArrayProperty>()) {
    auto prop = Cast<UArrayProperty>(inProp);
    FString inner;
    if (!upropType(prop->Inner, inner))
      return false;
    return canBuildTArrayProp(inner, prop->Inner) && writeWithModifiers(TEXT("unreal.TArray<") + inner + TEXT(">"), inProp, outType);
  } else if (inProp->IsA<UMulticastDelegateProperty>()) {
    auto prop = Cast<UMulticastDelegateProperty>(inProp);
    auto descr = m_haxeTypes.getDescriptor(prop->SignatureFunction);
    if (descr != nullptr) {
      return writeWithModifiers(descr->haxeType.toString(), inProp, outType);
    }
    return false;
  } else if (inProp->IsA<UDelegateProperty>()) {
    auto prop = Cast<UDelegateProperty>(inProp);
    auto descr = m_haxeTypes.getDescriptor(prop->SignatureFunction);
    if (descr != nullptr) {
      return writeWithModifiers(descr->haxeType.toString(), inProp, outType);
    }
    return false;
  } else if (inProp->IsA<UMapProperty>()) {
    auto prop = Cast<UMapProperty>(inProp);
    FString keyProp;
    FString valProp;
    if (!upropType(prop->KeyProp, keyProp) || !upropType(prop->ValueProp, valProp))
      return false;
    return canBuildTArrayProp(keyProp, prop->KeyProp) && canBuildTArrayProp(valProp, prop->ValueProp) &&
      writeWithModifiers(TEXT("unreal.TMap<") + keyProp + TEXT(", ") + valProp + TEXT(">"), inProp, outType);
  } else if (inProp->IsA<USetProperty>()) {
    auto prop = Cast<USetProperty>(inProp);
    FString element;
    if (!upropType(prop->ElementProp, element))
      return false;
    return canBuildTArrayProp(element, prop->ElementProp) &&
      writeWithModifiers(TEXT("unreal.TSet<") + element + TEXT(">"), inProp, outType);
  }
  // TODO:
  // TLazyObjectPtr
  // UAssetObjectPtr - TPersistentObjectPtr
  // UInterfaceProperty
  // UMapProperty (TMap)
  // USetProperty

  UE_LOG(LogHaxeExtern, Warning, TEXT("Property %s (class %s) not supported"), *inProp->GetName(), *inProp->GetClass()->GetName());
  return false;
}
